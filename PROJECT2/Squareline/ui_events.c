// This file was generated by SquareLine Studio
// SquareLine Studio version: SquareLine Studio 1.5.4
// LVGL version: 8.3.11
// Project name: SquareLine_Project

#include "ui.h"
#include "weather.h"
#include "mqtt_c_demo.h"
#include "chat.h"
/*=====================登录界面回调函数===========================*/
void LogIn(lv_event_t * e)
{
	if(loginUser()) {
	}
}

void Register(lv_event_t * e)
{
	registerUser();
}

void SelectProfilePhoto(lv_event_t * e)
{
    lv_obj_t * dropdown = lv_event_get_target(e);
    uint16_t selected_index = lv_dropdown_get_selected(dropdown);
    
    switch(selected_index) {
        case 0:
            lv_img_set_src(ui_Image30, &ui_img_funina_png);
            break;
        case 1:
            lv_img_set_src(ui_Image30, &ui_img_keqing_png);
            break;
        case 2:
            lv_img_set_src(ui_Image30, &ui_img_linnite_png);
            break;
        case 3:
            lv_img_set_src(ui_Image30, &ui_img_paimen_png);
            break;
        case 4:
            lv_img_set_src(ui_Image30, &ui_img_qiqi_png);
            break;
        default:
            break;
    }
}

/*==========================天气预报界面==============================*/
void ConfirmCheck(lv_event_t * e)
{

	if (strlen(cityname) == 0) {
		strcpy(cityname, "深圳");
	}
	printf("正在查询%s的天气\n", cityname);
	getWeather(cityname);
}

void CheckWeather(lv_event_t * e)
{
	lv_obj_t * dropdown = lv_event_get_target(e);
	lv_dropdown_get_selected_str(dropdown, cityname, sizeof(cityname));
	printf("Selected cityname: %s\n", cityname);
}

/*============================开关灯界面===============================*/

void * Lightimageshow(void){
    while(1){
        if(LEDSTATE[0] == false){
            lv_obj_add_flag(ui_ImageLight1, LV_OBJ_FLAG_HIDDEN);
        } else{
            lv_obj_clear_flag(ui_ImageLight1, LV_OBJ_FLAG_HIDDEN);
        }
            if(LEDSTATE[1] == false){
            lv_obj_add_flag(ui_ImageLight2, LV_OBJ_FLAG_HIDDEN);
        }else {
            lv_obj_clear_flag(ui_ImageLight2, LV_OBJ_FLAG_HIDDEN);
        } 
        if(LEDSTATE[2] == false){
            lv_obj_add_flag(ui_ImageLight3, LV_OBJ_FLAG_HIDDEN);
        } else{
            lv_obj_clear_flag(ui_ImageLight3, LV_OBJ_FLAG_HIDDEN);
        }
            if(LEDSTATE[3] == false){
            lv_obj_add_flag(ui_ImageLight4, LV_OBJ_FLAG_HIDDEN);
        }else{
            lv_obj_clear_flag(ui_ImageLight4, LV_OBJ_FLAG_HIDDEN);
        }
        usleep(1000000);
    }
}

void LightMQTTcontrl(){  // 放在screen4初始化
    pthread_t tid;
    int ret = pthread_create(&tid, NULL, Lightimageshow, NULL);
    if (ret == 0) {
        // printf("成功创建新Lightimageshow线程(tid: %lu)\n", (unsigned long)tid);
        pthread_detach(tid); // 分离线程，自动回收资源
    }else {
        printf("创建Lightimageshow线程失败(错误码: %d)\n", ret);
        tid = 0; // 重置为无效ID
    }
}

void LEDcontorl(lv_event_t * e)
{
    // 取消旧的MQTT线程
    if (g_mqtt_tid != 0) {
        // 先尝试取消线程
        int cancel_ret = pthread_cancel(g_mqtt_tid);
        if (cancel_ret == 0) {
            // printf("成功发送取消信号给旧MQTT线程（tid: %lu）\n", (unsigned long)g_mqtt_tid);
        } else {
            printf("取消旧MQTT线程失败（错误码: %d）\n", cancel_ret);
        }
        // 确保线程资源释放
        usleep(100000); // 100ms
        g_mqtt_tid = 0; // 重置线程ID
    }

    // 过滤
    lv_event_code_t event_code = lv_event_get_code(e);
    if (event_code != LV_EVENT_CLICKED) {
        return;
    }

    //获取当前按下的对象
    lv_obj_t *btn = lv_event_get_target(e);

    // 映射LEDSTATE数组
    int led_index = -1;
    if (btn == ui_Button3) {
        led_index = 0;
    } else if (btn == ui_Button4) {
        led_index = 1;
    } else if (btn == ui_Button5) {
        led_index = 2;
    } else if (btn == ui_Button6) {
        led_index = 3;
    }

    // 翻转LED
    if (led_index >= 0 && led_index < 4) {
        LEDSTATE[led_index] = !LEDSTATE[led_index];
        printf("LED%d已%s\n", led_index+7, LEDSTATE[led_index] ? "开启" : "关闭");
    }
    char buf[2] = {0};
	for (int i = 0; i < 4; i++){
		int fd = open("/dev/led_drv", O_RDWR);
		if (fd == -1){  perror("open");
			return -1;
		}
		buf[0] = LEDSTATE[i];   buf[1] = i+7;
		write(fd, buf, 2);
		close(fd);
	}

    // 创建新线程
    int create_ret = pthread_create(&g_mqtt_tid, NULL, MQTTinit, NULL);
    if (create_ret == 0) {
        // printf("成功创建新MQTT线程(tid: %lu)\n", (unsigned long)g_mqtt_tid);
        pthread_detach(g_mqtt_tid); // 分离线程，自动回收资源
    } else {
        printf("创建MQTT线程失败(错误码: %d)\n", create_ret);
        g_mqtt_tid = 0; // 重置为无效ID
    }
    

}

/*=============================聊天界面===================================*/ 
// screen5


void Chat(lv_event_t * e)
{
	lv_obj_t *btn = lv_event_get_target(e); // 获取当前按下的对象  ui_image15 29 31 32 33 34
    // 判断点击的是哪个按钮，并初始化对应的聊天窗口
    if (btn == ui_Image15) {
        chat_init("群聊");    // 初始化群聊窗口
        strcpy(chat_obj, "群聊");    // 设置当前聊天对象为群聊
    } else if (btn == ui_Image29) {
        chat_init("用户1");    // 初始化与用户1的聊天窗口
        strcpy(chat_obj, "用户1");    // 设置当前聊天对象为用户1
    } else if (btn == ui_Image31) {
        chat_init("用户2");
        strcpy(chat_obj, "用户2");
    } else if (btn == ui_Image32) {
        chat_init("用户3");
        strcpy(chat_obj, "用户3");
    } else if (btn == ui_Image33) {
        chat_init("用户4");
        strcpy(chat_obj, "用户4");
    } else if (btn == ui_Image34) {
        chat_init("用户5");
        strcpy(chat_obj, "用户5");
    }
}

void SendMessage(lv_event_t * e)
{
	// 获取输入框的内容
	 char message[256] = {0}; 
    strncpy(message, lv_textarea_get_text(ui_TextArea8), sizeof(message) - 1); 
    message[sizeof(message) - 1] = '\0';
	printf("发送消息: %s\n", message);printf("发送成功\n");
	// 清空输入框
	lv_textarea_set_text(ui_TextArea8, "");printf("清空输入框\n");
    send_message_to_server(message, chat_obj);
}

/*============================游戏界面===================================*/
void GameStart(lv_event_t * e)
{
	// Your code here
}

